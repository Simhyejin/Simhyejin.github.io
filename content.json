{"meta":{"title":"JENNY|시매","subtitle":"시매의 기록장","description":"Sim Hyejin's IT, Programming blog","author":"Sim Hyejin","url":"https://simhyejin.github.io"},"pages":[{"title":"ABOUT JENNY","date":"2019-11-04T08:39:55.060Z","updated":"2019-11-04T08:39:55.060Z","comments":false,"path":"about/index.html","permalink":"https://simhyejin.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"[자바성능튜닝이야기] 04 어디에  담아야 하는지...","slug":"javaPerfomanceTunning4","date":"2019-11-05T02:14:41.000Z","updated":"2019-11-05T02:42:44.598Z","comments":true,"path":"2019/11/05/javaPerfomanceTunning4/","link":"","permalink":"https://simhyejin.github.io/2019/11/05/javaPerfomanceTunning4/","excerpt":"","text":"이 글은 아직 작성 중이며 완성 되지 않은 상태입니다.자바 성능 튜닝 이야기(04 어디에 담아야 하는지…)을 읽고 공부하여 정리한 내용입니다. 목차 Collection 및 Map 인터페이스의 이해 Collection 인터페이스 Map 인터페이스 Set 관련 클래스 List 관련 클래스 Queue 관련 클래스 Map 관련 클래스 Collection 관련 클래스의 동기화 Collection 및 Map 인터페이스의 이해Collection 인터페이스 Collection : 상위 인터페이스 Set : 중복을 허용하지 않는 집합을 처리하기 위한 인터페이스 SortedSet : 오름차순을 갖는 Set 인터페이스 List : 순서가 있는 집합을 처리하기 위한 인터페이스중복을 허용하며 인덱스가 있어 위치를 지정하여 값을 찾을 수 있다. Queue : FIFO(First In First Out, 선입선출) 형태로 자료를 관리하는 인터페이스 Map 인터페이스 Map : Map은 key와 value의 쌍으로 구성된 객체의 잡합을 처리하기 위한 인터페이스중복되는 키를 허용하지않는다. SortedMap : 키를 오름차순으로 정렬하는 Map 인터페이스 Set 관련 클래스Set 인터페이스는 중복이 없는 집합 객체를 만들 때 유용하다.Set 인터페이스를 구현한 클래스로는 HashSet, TreeSet, LinkedHashSet 세가지가 있다. class desc HashSet 데이터를 해쉬 테이블에 담는 클래스로 순서 없이 저장 TreeSet red-black이라는 트리에 데이터를 담는 클래스로 값에 따라서 순서가 정해진다.데이터를 담으면서 동시에 정렬하기 때문에 HashSet보다 성능상 느리다. LinkedHashSet 헤쉬 테이블에 데이터를 담는데, 저장된 순서에 따라서 순서가 결정된다. List 관련 클래스List 인터페이스를 구현한 클래스들은 담을 수 있는 크기가 자동으로 증가되므로, 데이터의 개수를 확실히 모를 때 유용하다.List 인터페이스를 구현한 클래스로는 vector, ArrayList, LinkedList 세가지가 있다. class desc vector 객체 생성시에 크기를 지정할 필요가 없는 배열 클래스 ArrayList Vector LinkedList Queue 관련 클래스 Map 관련 클래스 Collection 관련 클래스의 동기화 참고 An Introduction to the Java Collections Framework https://onsil-thegreenhouse.github.io/programming/java/2018/02/21/java\\_tutorial\\_1-23/","categories":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}],"tags":[{"name":"자바성능튜닝이야기","slug":"자바성능튜닝이야기","permalink":"https://simhyejin.github.io/tags/자바성능튜닝이야기/"},{"name":"JAVA","slug":"JAVA","permalink":"https://simhyejin.github.io/tags/JAVA/"},{"name":"Collection","slug":"Collection","permalink":"https://simhyejin.github.io/tags/Collection/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}]},{"title":"[자바성능튜닝이야기] 03 왜 자꾸 String을 쓰지 말라는 거야","slug":"javaPerfomanceTunning3","date":"2019-11-05T01:53:22.000Z","updated":"2019-11-05T01:57:30.532Z","comments":true,"path":"2019/11/05/javaPerfomanceTunning3/","link":"","permalink":"https://simhyejin.github.io/2019/11/05/javaPerfomanceTunning3/","excerpt":"","text":"문자열String 짧은 문자열을 더할 경우 사용 제일 느림 StringBuffer 스레드 세이프해야 할 경우 사용 StringBuilder 스레드 세이프하지 않아도 될 때 사용 가장 빠름 JDK 5.0 이상JDK 5.0 이상부터는 컴파일러가 String으로 문자열을 더할 때 StringBuilder로 변환된다. 그래도String 클래스를 쓰는 대신 스레드와 관련이 있으면 StringBuffer를스레드 안전 여부와 상관이 없으면 StringBuilder를 사용을 권장! for 문에서 String 더하기를 할 경우 컴파일러가 StringBuilder로 변환은 하지만결국엔 Stirng이 객체를 반복적으로 생성하는 것과 같이 StringBuilder 객체가 반복적으로 생성됨. java1234String str = \"\";for (int i =0; i &lt; 10 ; i ++) &#123; str += \"a\";&#125; compiler 변환1234String str = \"\";for (int i =0; i &lt; 10 ; i ++) &#123; str = (new StringBuilder(String.valueOf(str))).append(\"a\").toString();&#125; 내 생각직접 속도와 메모리 사용량을 비교해보면 좋을거 같다.컴파일 결과도 볼 수 있으면 좋고! 나중에… 참고 개인블로그 - StringBuffer, StringBuilder 가 String 보다 성능이 좋은 이유와 원리 okky - 문자열(String) 붙일때 요령 GitHub -jdk1.5에서 String 더하기의 컴파일시의 최적화","categories":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}],"tags":[{"name":"자바성능튜닝이야기","slug":"자바성능튜닝이야기","permalink":"https://simhyejin.github.io/tags/자바성능튜닝이야기/"},{"name":"JAVA","slug":"JAVA","permalink":"https://simhyejin.github.io/tags/JAVA/"},{"name":"String","slug":"String","permalink":"https://simhyejin.github.io/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://simhyejin.github.io/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://simhyejin.github.io/tags/StringBuilder/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}]},{"title":"[자바성능튜닝이야기] 02 내가 만든 프로그램의 속도를 알고 싶다","slug":"javaPerfomanceTunning2","date":"2019-11-05T01:39:39.000Z","updated":"2019-11-05T02:06:32.916Z","comments":true,"path":"2019/11/05/javaPerfomanceTunning2/","link":"","permalink":"https://simhyejin.github.io/2019/11/05/javaPerfomanceTunning2/","excerpt":"","text":"프로파일링 툴 vs APM 툴 프로파일링툴 APM 툴 목적 소스 레벨의 분석을 위한 툴 실시간 모니터링을 위한 툴 특징 1. 애플리케이션의 세부 응답 시간까지 분석할 수 있다.2. 메모리 사용량을 객체나 클래스, 소스의 라인 단위까지 분석할 수 있다. 1. 애플리케이션의 장애 상황에 대한 모니터링 및 문제점 진단2. 서버의 사용자 수나 리소스에 대한 모니터링을 할 수 있다. * AMP = Application Performance Mornitoring scouter요새 자주 사용하고 있는 모니터링 툴:D스카우터는 APM이다 Scouter is an open source APM (Application Performance Management) tool. System 클래스System.currentTimeMillis() vs System.nanoTime()12static long currentTimeMillis(): 현재의 시간을 ms(밀리초)로 리턴한다.(1/1,000초) currentTimeMillis()는 UTC라는 시간 표준 체계를 따르는데, 1970년 1월 1일부터의 시간을 long타입으로 리턴해 준다. 이 시간값을 변환하면 현재 날짜를 구할 수도 있다. 12static long nanoTime(): 현재의 시간을 ns(나노초)로 리턴한다.(1/1,000,000,000초) nanoTime()은 JDK 5.0부터 추가된 메서드다.nanoTime()은 시간 측정 목적으로 사용된다.","categories":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}],"tags":[{"name":"자바성능튜닝이야기","slug":"자바성능튜닝이야기","permalink":"https://simhyejin.github.io/tags/자바성능튜닝이야기/"},{"name":"JAVA","slug":"JAVA","permalink":"https://simhyejin.github.io/tags/JAVA/"},{"name":"프로파일링툴","slug":"프로파일링툴","permalink":"https://simhyejin.github.io/tags/프로파일링툴/"},{"name":"APM툴","slug":"APM툴","permalink":"https://simhyejin.github.io/tags/APM툴/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}]},{"title":"[자바성능튜닝이야기] 01 디자인 패턴, 꼭 써야한다.","slug":"javaPerfomanceTunning1","date":"2019-11-04T08:47:09.000Z","updated":"2019-11-05T02:42:01.988Z","comments":true,"path":"2019/11/04/javaPerfomanceTunning1/","link":"","permalink":"https://simhyejin.github.io/2019/11/04/javaPerfomanceTunning1/","excerpt":"","text":"이 글은 아직 작성 중이며 완성 되지 않은 상태입니다.자바 성능 튜닝 이야기(01 디자인 패턴, 꼭 써야한다.)을 읽고 공부하여 정리한 내용입니다. 목차 MVC 패턴 J2EE 패턴 Intercepting Filter Front Controller Business Delegate MVC 패턴 정리중 입니다. J2EE 패턴core J2EE PATTERNS Intercepting Filter정의 요청 타입에 따라 다른 처리를 하기 위한 패턴 Use an Intercepting Filter as a pluggable filter to pre and postprocess requests and responses.A filter manager combines loosely coupled filters in a chain, delegating control to the appropriate filter.In this way, you can add, remove, and combine these filters in various ways without changing existing code. 결과내이해참조 corej2eepatterns - Intercepting Filter 개인블로그 - J2EE - intercepting filter 패턴 위키피디아 - Intercepting filter pattern Front Controller정의 Use a Front Controller as the initial point of contact for handling all related requests.The Front Controller centralizes control logic that might otherwise be duplicated, and manages the key request handling activities. 요청 전후에 처리하기위한 컨트롤러를 지정하는 패턴 장점 중앙 집중 제어 (Centralizes control) 관리성 향상 (Improves manageability) 재사용성 향상 (Improves reusability) 역할 분리 향상(Improves role separation) 내이해 모든 요청을 중앙 관리하는 컨트롤러 Spring의 DispatcherServlet 참조 corej2eepatterns - Front Controller 위키피디아 - Front controller 개인 블로그 - Spring의 MVC &amp; Front Controller Pattern 개인 블로그 - 프론트 컨트롤러 패턴, Front Controller Pattern [Business Delegate](http://www.corej2eepatterns.com/Business Delegate.htm)정의 Use a Business Delegate to encapsulate access to a business service.The Business Delegate hides the implementation details of the business service, such as lookup and access mechanisms. 비즈니스 서비스 접근을 캡슐화하는 패턴 결과 비즈니스 서비스와 프레젠테이션 계층의 커플링(coupling)을 줄이고, 유지보수 향상 비즈니스 서비스 예외 변환 가용성 향상 비즈니스 계층보다 단순하고 균일한 인터페이스 제공 성능 향상 원격 숨김 내 이해직접적인 로직인 서비스단을 숨겨서 프론트단인 클라이언트가 딜리게이터를 통해 실행프론트와 서비스 로직의 중간 매개체 참조 corej2eepatterns - Business Delegate 위키피디아 - Business delegate pattern 개인 블로그 - Business delegate pattern Session Facade정의 비즈니스 티어 컴포넌트를 캡슐화하고, 원격 클라이언트에서 접근할 수 있는 서비스를 제공하는 패턴 결과내이해참조Service Locator정의 서비스와 컴포넌트 검색을 쉽게하는 패턴 결과내이해참조Transfer Object정의 일명 Value Object 패턴이라고 많이 알려져 있다. 데이터 전송하기 위한 객체에 대한 패턴 결과내이해참조Data Access Object정의 일명 DAO라고 많이 알려져있다. DB에 접근을 전담하는 클래스를 추상화하고 캡슐화 결과내이해참조","categories":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}],"tags":[{"name":"자바성능튜닝이야기","slug":"자바성능튜닝이야기","permalink":"https://simhyejin.github.io/tags/자바성능튜닝이야기/"},{"name":"JAVA","slug":"JAVA","permalink":"https://simhyejin.github.io/tags/JAVA/"},{"name":"J2EE패턴","slug":"J2EE패턴","permalink":"https://simhyejin.github.io/tags/J2EE패턴/"},{"name":"MVC패턴","slug":"MVC패턴","permalink":"https://simhyejin.github.io/tags/MVC패턴/"}],"keywords":[{"name":"Book","slug":"Book","permalink":"https://simhyejin.github.io/categories/Book/"},{"name":"JAVA","slug":"Book/JAVA","permalink":"https://simhyejin.github.io/categories/Book/JAVA/"}]},{"title":"TIME_WAIT State","slug":"TIME-WAIT","date":"2016-07-13T07:47:10.000Z","updated":"2019-11-05T02:40:25.524Z","comments":true,"path":"2016/07/13/TIME-WAIT/","link":"","permalink":"https://simhyejin.github.io/2016/07/13/TIME-WAIT/","excerpt":"","text":"TIME&#95;WAIT 상태가 늘어나면 소켓이 고갈되어 커넥션 타임아웃이 발생한다는 얘기가 있다. TIME&#95;WAIT 은 어떠한 경우에 발생하고 어떤 특징이 있는지 살펴보고 소켓 고갈과의 연관성을 알아본다. 목차 TCP Connecion Close : 4 way hand-shake TIME_WAIT Linger 옵션 TCP Close : 4 way hand-shake먼저 TCP의 Connection Close에 살펴본다.TCP는 Connection 연결을 3 Way Hand-Shake의 방식을 사용했다면Connection 종료는 4 Way Hand-Shake의 방식으로 한다. TIME_WAITActive Close, 즉 먼저 close()를 요청한 곳에서 TIME&#95;WAIT state가 발생하며 2MSL동안 기다렸다가 Close 한다. MSL(Maximum Segment Lifetime)RFC793 specifies the MSL as 2 minutes.Common implementation values, however, are 30 seconds, 1 minute, or 2 minutes. TIME_WAIT 이 필요한 이유TIME_WAIT 특징 Linger 옵션1234struct linger &#123; int l_onoff; /* option on/off */ int l_linger; /* linger time */&#125;; 소켓에는 데이타가 아직 남아 있을때 종료 방식을 결정하는 링거 옵션이 있다. 아래 3가지 경우로 나뉜다. l_onoff = 1, l_linger = 0즉시 종료하고 Buffer에 남아 있는 데이타는 버린다. 비정상 종료로 RST를 보내고 즉시 연결을 끊는다. l_onoff = 1, l_linger = non-zero명시된 시간(초)동안 정상적으로 진행하며 그 이후에는 비정상 종료(RST) 처리한다.만일 Buffer에 전송되지 못한 메시지가 남아 있다면 명시된 시간 동안은 어플리케이션이 close()를 진행하지 못하고 최종적으로 RST를 보내기 위해 sleep 상태에서 대기하기 때문에 어플리케이션 지연 현상이 발생하므로 유의해야 한다. non-blocking 으로 동작하는 것도 가능은 하다. l_onoff = 0정상적인 4-way handshake 종료 과정을 진행하며 소켓의 기본값이다. RST는 비정상 종료시 보내는 패킷이다. 수신한 상대방은 Connection reset by peer 오류가 나게 된다.양쪽 모두 바로 연결이 끊어지며, 양쪽 모두 TIME&#95;WAIT 상태가 남지 않는다는 점에서 가장 빠르고 깔끔해 유용해보이지만 문제는 비정상 종료라는 점이다.RST는 부작용를 야기할 수 있다. 또한 양쪽 모두에 TIME&#95;WAIT 을 남기지 않기 때문에 패킷의 오동작을 막아줄 장치가 없다. 어떠한 TIME&#95;WAIT 도 남아 있지 않아야 할 특수한 목적이 아니라면, 일반적으로는 링거 옵션을 사용하지 않아야 하고 RST 비정상 종료 패킷을 보내는 일이 없어야 한다. 정리잦은 연결과 종료는 TIME&#95;WAIT 상태로 소켓 고갈이 일어날 수 있다.대부분의 문서를 찾아보면 Linger 옵션을 통해 TIME&#95;WAIT 을 없애려고 한다. 하지만 TCP Protocol은 오랜 역사를 가지고 변해왔지만 TIME&#95;WAIT 기능은 여전히 남아있다. 이는 TIME&#95;WAIT 상태가 필요한 존재이기 때문이지 않을까.","categories":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"NETWORK","slug":"CSE/NETWORK","permalink":"https://simhyejin.github.io/categories/CSE/NETWORK/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://simhyejin.github.io/tags/tcp-ip/"},{"name":"network","slug":"network","permalink":"https://simhyejin.github.io/tags/network/"},{"name":"tcp close","slug":"tcp-close","permalink":"https://simhyejin.github.io/tags/tcp-close/"},{"name":"TIME_WAIT","slug":"TIME-WAIT","permalink":"https://simhyejin.github.io/tags/TIME-WAIT/"},{"name":"4 Way Hand Shake","slug":"4-Way-Hand-Shake","permalink":"https://simhyejin.github.io/tags/4-Way-Hand-Shake/"}],"keywords":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"NETWORK","slug":"CSE/NETWORK","permalink":"https://simhyejin.github.io/categories/CSE/NETWORK/"}]},{"title":"Tip 1 : 연결지향(Connection Oriented) 프로토콜과 비연결(Connectionless) 프로토콜의 차이점을 이해하라!","slug":"connectionoriented-connectionless","date":"2016-07-04T12:33:09.000Z","updated":"2019-11-05T02:01:28.837Z","comments":true,"path":"2016/07/04/connectionoriented-connectionless/","link":"","permalink":"https://simhyejin.github.io/2016/07/04/connectionoriented-connectionless/","excerpt":"","text":"Tip 1 : Understand the Difference between Connected and Connectionless Protocols네트워크를 공부하다보면 연결지향(Connection-Oriented)와 비연결(Connectionless)라는 말을 들어보셨을 것입니다.이번 포스트는 Connection-Oriented과 Connectionless에 대해 포스트하겠습니다. SummaryTCP는 Connection-Oriented 프로토콜 입니다. 1:1로 연결 상태를 유지하여 통신하는 것을 말합니다.IP와 UDP 는 Connectionless 프로토콜 입니다. 연결 상태를 유지하는 것이 아니라 주소를 가지고 다음 라우터나 목적지로 전달만 하여 데이타그램에 대해 관여 하지 않습니다. Connection Oriented 와 Connectionless 비교 Connection Oriented Connectionless TCP IP, UDP Segment Datagram 프로토콜에 의해 연속적으로패킷의 상태 정보 유지1 각각의 패킷들이 독립적2 reliable unreliable 1:1 1:NN:M Connection Oriented Protocol의 3단계 연결 (Connection Establish) 데이타 전송 단계(Data Transfer) 연결 종료 (Connection Colose) ✩Connectionless Protocol은 Connection Oriented Protocol의 기반이다.✩TCP/IP은 4계층의 프로토콜 스택으로 이루어져있습니다. TCP/IP은 4계층 Application TCP/UDP IP Interface TCP와 UDP는 IP 프로토콜 위에 존재합니다. 즉, IP는 TCP/IP 스택이 만들어지는 기초가 됩니다.IP는 성능 중심(Best Effort)의 unreliable, Connecionless 서비스를 제공합니다. 상위 계층에서 패킷을 받아 IP 패킷으로 캡슐화하고 이를 하드웨어 인터페이스에 전송합니다. IP는 한번 전송하면 그 패킷에 관여하지 않습니다. TCP가 Connectionless IP위에서 어떻게 연결형 서비스를 하는지 알아 보겠습니다.TCP는 세그먼트(Segment)라 불리는 패킷을 unreliable한 IP 데이타그램(Datagram)을 통해서 손상시키지않고 순서대로 목적지에 도달하도록 합니다.신뢰성을 제공하기위해 TCP는 기본 IP 서비스에서 3가지 추가했습니다. TCP 세그먼트 내의 Cheksum을 제공한다. 데이터가 전송 도중에 손상되지 않았음을 증명합니다. 각 바이트 마다 일정한 Sequence Number할당합니다. 데이터가 순서대로 도착하지 않을경우 바로 잡을 수 있습니다. TCP는 모든 세그먼트가 잘 도착하였는지 알기 위해 Acknowledgment &amp; Retransmission 메커니즘을 제공합니다. UDP는 신뢰성 없는 비연결 서비스를 제공합니다. IP 프로토콜에 2가지 기능을 추가했습니다.UDP = 기본 IP 서비스 + (선택적 CheckSum + Port)TCP/UDP는 자신의 고유 헤더와 데이터를 보호하기 위해 체크섬 제공.포트는 데이터를 올바른 목적지 애플리케이션에 역다중화하는 방법을 제공. [1] 패킷의 상태 정보 유지 : 전화와 같다. 전화로 대화하는 동안 누구와 통화를 하는지 이미 알고 있다. 또한 전화가 열결되어 있는 동안 상대방의 전화번호를 다시 누를 필요도 없다. [⤿]() [2] 각가의 패킷들이 독립적 : 편지와 같다. 편지들은 서로 간의 정보를 유지하지 않는다. 또한, 우체국은 편지가 분실되거나 지연되거나 배달 순서가 바뀌어 전달되지 않아도 보증하지 않는다. Effective TCP/IP Programming&#45; 44 Tips to Improve Your Network Programs by C. Snader #CSE #Network다음 포스트 &gt;","categories":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"NETWORK","slug":"CSE/NETWORK","permalink":"https://simhyejin.github.io/categories/CSE/NETWORK/"}],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://simhyejin.github.io/tags/tcp-ip/"},{"name":"network","slug":"network","permalink":"https://simhyejin.github.io/tags/network/"},{"name":"connection oriented","slug":"connection-oriented","permalink":"https://simhyejin.github.io/tags/connection-oriented/"},{"name":"connectionless","slug":"connectionless","permalink":"https://simhyejin.github.io/tags/connectionless/"}],"keywords":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"NETWORK","slug":"CSE/NETWORK","permalink":"https://simhyejin.github.io/categories/CSE/NETWORK/"}]},{"title":"Hexo Generator Alias","slug":"hexo-generator-alias","date":"2016-06-30T12:54:41.000Z","updated":"2019-11-04T08:38:41.489Z","comments":true,"path":"2016/06/30/hexo-generator-alias/","link":"","permalink":"https://simhyejin.github.io/2016/06/30/hexo-generator-alias/","excerpt":"","text":"이번 포스트는 Hexo Generator Alias라는 플러그인에 대해 소개하겠습니다.저는 url Redirection 을 하기 위해 사용하였습니다. 얼마 전 검색 엔진 최적화(SEO)에 맞춰 url을 내용과 구체적으로 관련있게 하기위해 포스트 파일명의 이름을 변경하였습니다.2번째 포스트인 Hexo+GitHub pages은 포스트 파일 명이 hexo-git 에서 hexo-github-pages 으로 변경되었습니다. 이미 색인된 상태인지 구글에 예전 페이지가 남아있어 404 에러를 발생시켰습니다.구글 웹마스터 도구 &gt; Google 색인 &gt; URL 삭제로 이전 URL을 삭제하였습니다. 하지만, ‘url 오류’라는 크롤링 오류가 계속 발생하여 Hexo Generator Alias 플러그인으로 이전 URL을 현 URL로 Redirecion 하였습니다. Hexo Generator Alias 플러그인Hexo Generator Alias : Generates alias pages for redirecting to posts, pages or URL.URL, 페이지, 포스트로 리다이렉션하기 위한 에일리어스 페이지를 생성하는 플러그인이다. 설치터미널을 열고 hexo가 설치되어있는 blog 폴더에서 npm을 통해 Hexo Generator Alias 플러그인을 설치한다. 1npm install hexo-generator-alias --save 이용법 Post file 에서 alias 12345alias: about/index.htmlalias:- about/index.html- bar/index.html 또는 _config.yml에서 alias123alias: api/index.html: api/classes/Hexo.html plugins/index.html: https://github.com/tommy351/hexo/wiki/Plugins 나의 사용기저는 2번째 방법인 _config.yml에서 alias를 지정했습니다.이전 페이지 html path : 현재 페이지 html path를 설정하시면 됩니다. 12alias: /2016/06/20/hexo-git/index.html: /2016/06/20/hexo-github-pages/index.html 이로 인해https://simhyejin.github.io/2016/06/20/hexo-git/— Redirection —&gt;https://simhyejin.github.io/2016/06/20/hexo-github-pages/이전 페이지 url을 눌러도 현 페이지로 이동합니다.URL Redirect로 삭제된 페이지를 현 페이지에 연결하는 것은 좋은 방법이 아닌것 같습니다.하지만, 404 에러를 발생시키는 이전 페이지 노출로 인해 URL Redirection을 해보았습니다.Hexo Generator Alias 플러그인으로 리다이렉션 하는 법 말고 다른 좋은 방법을 아시는 분은 알려주세요:) #Blog #Hexo #Plugin&lt; 이전 포스트 Hexo 테마 적용하기","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://simhyejin.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://simhyejin.github.io/tags/hexo/"},{"name":"plugin","slug":"plugin","permalink":"https://simhyejin.github.io/tags/plugin/"},{"name":"hexo generator alias","slug":"hexo-generator-alias","permalink":"https://simhyejin.github.io/tags/hexo-generator-alias/"},{"name":"redirect","slug":"redirect","permalink":"https://simhyejin.github.io/tags/redirect/"},{"name":"alias","slug":"alias","permalink":"https://simhyejin.github.io/tags/alias/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]},{"title":"[Markdown] 마크다운 문법","slug":"Markdown-syntax","date":"2016-06-29T16:41:00.000Z","updated":"2019-11-05T05:30:29.916Z","comments":true,"path":"2016/06/30/Markdown-syntax/","link":"","permalink":"https://simhyejin.github.io/2016/06/30/Markdown-syntax/","excerpt":"","text":"마크다운 문법에 대해 소개하겠습니다. 목차 제목 Headers 인용 Blockquotes 코드 블럭 Code Blocks 인라인 코드 Inline Code Blocks 강조 Emphasis 수평선 Horizontal Rules 링크 Links 외부 링크 External Links 내부 링크 Internal (Anchored) Links 리스트 Lists 순서 있는 리스트 Ordered Lists 순서 없는 리스트 Unordered Lists 테이블 Tables 이미지 Adding Images 각주 Footnotes 마크다운 문법제목 Headers#으로 시작하는 텍스트.#은 하나부터 여섯개까지 쓸 수 있고, #이 늘어날때마다 제목의 수준은 내려간다.(보통 글씨 크기가 작아진다.) 마크다운 실행결과 # h1## h2### h3#### h4##### h5###### h6 h1 h2 h3 h4 h5 h6 또는 -, =을 이용하여 h1, h2를 쓸 수 있다. 마크다운 실행결과 h1===h2— h1 h2 인용 Blockquotes&gt;으로 시작하는 텍스트 마크다운 실행결과 &gt; 인용문 인용문 &gt; 인용문&gt;&gt; 인용문안의 인용문 인용문 인용문안의 인용문 코드 블럭 Code Blocks``` 혹은 ~~~코드 첫 줄과 마지막 줄에 Back quote ( ` ) 또는 물결( ~ ) 3개 삽입 마크다운 실행결과 ```이것은코드 블럭입니다```~~~ 이것은 코드 블럭입니다~~~ 123이것은코드 블럭입니다123이것은코드 블럭입니다 첫 ``` 옆에 타입을 지정할 수 있다. (ex c, java, xml, json 등등) ```cvoid f() printf(%s,“이것은 c 코드 입니다”);}``` 123void f()&#123; printf(%s,\"이것은 c 코드 입니다\");&#125; 인라인 코드 Inline Code Blocks`(Back quote)로 감싸진 텍스트 마크다운 실행결과 `인라인 코드 블럭` 인라인 코드 블럭 강조 Emphasis기울여 쓰기(italic) : * 또는 _로 감싼 텍스트굴게쓰기(bold) : ** 또는 __로 감싼 텍스트 마크다운 실행결과 *기울여쓰기(italic)*_기울여쓰기(italic)_**굵게쓰기(bold)**__굵게쓰기(bold)__ 기울여쓰기(italic)기울여쓰기(italic)굵게쓰기(bold)굵게쓰기(bold) 수평선 Horizontal Rules- 또는 * 또는 _ 을 3개 이상 작성(단, -을 사용할 경우 header로 인식할 수 있으니 이 전 라인은 비워두어야한다.) 마크다운 실행결과 --- *** ___ 링크 Links외부 링크 External Links[링크](http://example.com &quot;링크 설명-마우스 hover시 나타나는 설명 문구&quot;) 인라인 링크[링크1][1] [1]: http://example1.com/ &quot;링크1 설명&quot; 참조 링크&lt;example.com/&gt; &lt;example@example.com&gt; url 링크 마크다운 실행결과 인라인 링크 [Google](http://www.google.co.kr \"구글\") Google 참조 링크 [Google][1][Naver][2][1]: http://google.com/ “구글”[2]: http://naver.com/ “네이버” GoogleNaver URl 링크&#60;http://google.com/&#62;&#60;example@gmail.com/&#62; http://google.com&#101;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d; 내부 링크 Internal (Anchored) Links&lt;div id=&quot;index&quot;&gt;목차&lt;/div&gt; html css id를 통해 내부 링크를 사용할 수 있다.[링크](#id) 내부 링크 마크다운 실행결과 [목차](#index) 목차 리스트 Lists순서 있는 리스트 Ordered ListsNo. 숫자 다음 .을 찍는다. (적힌 숫자랑 상관없이 순서대로 번호가 매겨진다.) 마크다운 실행결과 1. list item 11. list item 22. list item 30. list item 43. list item 5 list item 1list item 2list item 3list item 4list item 5 순서 없는 리스트 Unordered Lists*, +, - 으로 시작 마크다운 실행결과 * list item 1 * list item 1-1 * list item 2-1 * list item 1-2 list item 1list item 1-1list item 2-1list item 1-2 + list item 1 + list item 1-1 + list item 2-1 + list item 1-2 list item 1list item 1-1list item 2-1list item 1-2 - list item 1 - list item 1-1 - list item 2-1 - list item 1-2 list item 1list item 1-1list item 2-1list item 1-2 * list item 1 + list item 1-1 - list item 2-1 + list item 1-2 list item 1list item 1-1list item 2-1list item 1-2 테이블 Tables 마크다운 실행결과 테이블 생성Header 1 &#124; Header 2&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &#124; &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;Content 1 &#124; Content 3Content 2 &#124; Content 4 Header 1Header 2Content 1Content 3Content 2Content 4 테이블 정렬&#124; Header 1 &#124; Header 2 &#124; Header 3 &#124;&#124; :&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &#124; :&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;: &#124; &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;: &#124;&#124; Left &#124; Center &#124; Right &#124; Header 1Header 2Header 3LeftCenterRight 이미지 Adding Images 마크다운 실행결과 인라인 이미지!&#91;alt text&#93;&#40;/test.png &#41; 링크 이미지!&#91;alt text&#93;&#40;image_URL&#41; 참조 이미지!&#91;alt text&#93;&#91;1&#93;&#91;1&#93;: /test.png 각주 Footnotes 마크다운 실행결과 각주입니다[^id] [^id]: 각주에 대한 설명. 각주입니다11 각주 설명 : 설명설명 GitHub에서는 footnote를 지원해주지 않는다. html 태그를 통해 각주 사용 12&lt;div id =&quot;footnotes-p&quot;&gt;각주입니다&lt;sup&gt;[1](#footnotes)&lt;/sup&gt;&lt;/div&gt;&lt;div id =&quot;footnotes&quot;&gt;[1](#footnotes-p) 각주 설명 : 설명설명&lt;/div&gt; #Blog #Markdown< 이전 포스트 [Markdown] title 대괄호[] 사용하기","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://simhyejin.github.io/tags/markdown/"},{"name":"마크다운","slug":"마크다운","permalink":"https://simhyejin.github.io/tags/마크다운/"},{"name":"markdown syntax","slug":"markdown-syntax","permalink":"https://simhyejin.github.io/tags/markdown-syntax/"},{"name":"마크다운 문법","slug":"마크다운-문법","permalink":"https://simhyejin.github.io/tags/마크다운-문법/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]},{"title":"Hexo 테마 적용하기","slug":"hexo-themes","date":"2016-06-24T07:11:20.000Z","updated":"2019-11-05T02:41:36.828Z","comments":true,"path":"2016/06/24/hexo-themes/","link":"","permalink":"https://simhyejin.github.io/2016/06/24/hexo-themes/","excerpt":"","text":"이전 포스트 Hexo+GitHub pages에서 Hexo 와 _GitHub Pages_를 연동하여 블로그를 만들었습니다. 이번 포스트는 테마를 바꿔 블로그를 꾸며 보도록 하겠습니다.Hexo 는 다양한 테마를 지원해 줍니다. Hexo Themes 에서 원하는 테마를 고를 수 있습니다.데스크탑, 태블릿, 모바일 등 지원 가능한 반응형 테마를 고르기 위해 responsive을 검색하였고 그 중 Hueman이라는 테마를 적용하엿습니다.Hueman 테마 적용법과 테마 설정(CSS 수정, Thumbnail, Disqus)에 대해 소개하겠습니다. 목차 Hueman 테마 적용하기 Hueman 설치 Hueman 설정 Theme Color Thumbnail Disqus Hueman 테마 적용하기설치 터미널을 열어 hexo init했던 폴더(이하 blog 폴더)에 들어갑니다. Heuman 테마를 themes/hueman 폴더에 clone합니다. 12$ cd blog$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman blog 폴더에 있는 _config.yml에서 ##Theme 부분을 landscape 에서 hueman 으로 수정합니다. 12## Themes: https://hexo.io/themes/theme: hueman themes/hueman 폴더에 있는 _config.yml.example를 _config.yml로 바꿉니다. (Optional) 최신 버전을 다운 받기위해 pull해줍니다. 12$ cd themes/hueman$ git pull (Optional) Hueman 테마의 Insight Search 검색엔진을 사용하기위해 npm으로 hexo-generator-json-content을 설치합니다. 1$ npm install -S hexo-generator-json-content 설정themes/hueman 폴더에 있는 _config.yml에서 아래의 테마 설정을 바꿀 수 있습니다. Theme Menu Customize(Logo, Thema Color, Highlight, Sidebar, Thumbnail, Favicon, Social Links) Widgets : Recent Posts, Category, Archive, Tag, Tag Cloud, Links Search Comment : Disqus Share Plugins Miscellaneous - Theme Color저는 제 로고의 보라색을 따와 Theme Color를 보라색으로 설정했습니다.Hueman 테마의 Theme Color는 오른쪽 사이드바의 Follow영역의 색을 바꾸게 해줍니다.또한 Theme Color는 이외에도 여러군데 사용이됩니다. 게시물 hover 글자 드래그 링크등이 Theme Color가 적용됩니다.저의 Theme Color 보라색인 링크 글씨과 검은색 글씨의 눈으로 보기에 차이가 나지않아서 링크 글씨의 색을 지금 보이는 것과 같은 하늘색으로 바꾸었습니다. ** [링크 색 바꾸기] **themes/hueman/source/css/_partial 폴더의 article.styl 파일을 수정하면 됩니다. 12345.article-entry //... a //링크 color: \"원하는색상\" //... 이 외에도 styl 파일을 수정하면 커스터마이징 가능합니다. - Thumbnailthemes/hueman 폴더에 있는 _config.yml에서 true, false 로 설정 할 수 있습니다. 12customize: thumbnail: true # enable posts thumbnail, options: true, false 포스트에 thumbnail 추가하기source/images에 이미지 파일을 넣고 포스트 font-matter에 thumbnail을 추가하고 이미지 경로를 넣어줍니다.12345---title: Hexo 테마 적용하기date: 2016-06-24 16:11:20thumbnail: /images/hueman.jpg--- 혹은 이미지 url인 경우에는 thumbnail을 추가하고 이미지 경로 url을 넣어줍니다. 12345---title: Hexo 테마 적용하기date: 2016-06-24 16:11:20thumbnail: https://example.com/image.jpg--- - Disqusthemes/hueman 폴더에 있는 _config.yml에서 #Comment 부분의 disqus 에 _disqus shortname_을 적어줍니다. 123# Commentcomment: disqus: [Disqus Shortname] # enter disqus shortname here [ShortName 만들기 및 확인하기]먼저 Disqus 계정이 있어야합니다. 회원가입 또는 SNS(페이스북, 트위터, 구글)로 로그인 가능합니다.0. Get Started 클릭 후 블로그 이름 설정(예시: aaaaba)[※블로그 이름이 Short Name으로 설정됩니다]0. 왼쪽 General 클릭하면 ShortName 확인 할수 있습니다. #Blog #Hexo&lt; 이전 포스트 Hexo+GitHub pages다음 포스트 &gt; Hexo Generator Alias","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://simhyejin.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://simhyejin.github.io/tags/hexo/"},{"name":"themes","slug":"themes","permalink":"https://simhyejin.github.io/tags/themes/"},{"name":"hueman","slug":"hueman","permalink":"https://simhyejin.github.io/tags/hueman/"},{"name":"thumbnail","slug":"thumbnail","permalink":"https://simhyejin.github.io/tags/thumbnail/"},{"name":"disqus","slug":"disqus","permalink":"https://simhyejin.github.io/tags/disqus/"},{"name":"theme color","slug":"theme-color","permalink":"https://simhyejin.github.io/tags/theme-color/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]},{"title":"[Markdown] title 대괄호[] 사용하기","slug":"markdown-post-title","date":"2016-06-24T06:22:11.000Z","updated":"2019-11-04T08:38:41.494Z","comments":true,"path":"2016/06/24/markdown-post-title/","link":"","permalink":"https://simhyejin.github.io/2016/06/24/markdown-post-title/","excerpt":"","text":"Hexo로 블로그를 운영하며 마크다운(Markdown)을 사용하여 포스트를 작성하고 있습니다.포스트 제목 앞에 대괄호를 썻더니 오류가 발생하였습니다. 이에 대한 해결방안을 가져왔습니다. YAMLException: can not read a block mapping entry 해결하기위 사진과 같이 포스트를 작성할 때 title 앞에 대괄호를 넣으면 아래와 같은 Error가 발생합니다. 1234ERROR Process failed: _posts/test.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 5: date: 2016-06-24 15:19:38 ^ 해결방법은 간단합니다.아래와 같이 title을 “” 큰따옴표 or ‘’ 작은따옴표로 감싸주시면 됩니다. 문제해결 완료 :) #Blog #Markdown다음 포스트 &gt; [Markdown] 마크다운 문법","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://simhyejin.github.io/tags/hexo/"},{"name":"post","slug":"post","permalink":"https://simhyejin.github.io/tags/post/"},{"name":"title","slug":"title","permalink":"https://simhyejin.github.io/tags/title/"},{"name":"markdown","slug":"markdown","permalink":"https://simhyejin.github.io/tags/markdown/"},{"name":"square bracket","slug":"square-bracket","permalink":"https://simhyejin.github.io/tags/square-bracket/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]},{"title":"OWASP TOP 10 (2013)","slug":"owasp13","date":"2016-06-22T06:01:47.000Z","updated":"2019-11-05T02:45:03.741Z","comments":true,"path":"2016/06/22/owasp13/","link":"","permalink":"https://simhyejin.github.io/2016/06/22/owasp13/","excerpt":"","text":"OWASPOWASP(Open Web Application Security Project)는 신뢰할 수있는 애플리케이션을 개발 및 유지보수하기 위해 노력하는 오픈 커뮤니티입니다. 주로 애플리케이션에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하며, 10대 웹 애플리케이션의 취약점(OWASP TOP 10)을 발표합니다. Top 10 프로젝트의 목표는 조직에서 직면한 가장 중요한 몇 가지 위험요소를 식별해 애플리케이션 보안에 대한 인식을 향상시키는 데 있습니다. OWASP TOP 10은 웹 애플리케이션 취약점 중에서 빈도가 높고, 보안상 영향을 크게 줄 수 있는 것들 10가지를 선정하여 2004년, 2007년, 2010년, 2013년을 기준으로 발표하고 있습니다. OWASP의 모든 문서는 애플리케이션 보안성 향상에 관심 있는 모두에게 무료이며 OWASP홈페이지에서 확인 가능합니다. 2016년 OWASP TOP 10이 나오기 전에 2013 OWASP TOP 10을 살펴 보려고 합니다. 2010 과 2013 OWASP TOP 10 비교 2013 OWASP TOP 10 A1 : Injection (인젝션, 삽입)SQL, 운영체제, LDAP 인젝션 취약점은 신뢰할 수 없는 데이터가 명령어나 질의문의 일부분으로서 인터프리터로 보내질 때 발생한다. 공격자의 악의적인 데이터는 예상하지 못하는 명령을 실행하거나 적절한 권한 없이 데이터에 접근하도록 인터프리터를 속일 수 있다. A2 : Broken Authentication and Session Management (취약한 인증 및 세션 관리)인증과 세션 관리와 관련된 애플리케이션 기능은 정확하게 구현되어 있지 않아서, 공격자가 패스워드, 키 또는 세션 토큰을 해킹하거나 다른 구현 취약점을 공격하여 다른 사용자 ID로가장할 수 있다. A3 : Cross-Site Scripting (XSS, 크로스 사이트 스크립팅)XSS 취약점은 애플리케이션이 신뢰할 수 없는 데이터를 가져와 적절한 검증이나 제한 없이 웹 브라우저로 보낼 때 발생한다. XSS는 공격자가 피해자의 브라우저에 스크립트를 실행하여 사용자 세션 탈취, 웹 사이트 변조, 악의적인 사이트로 이동할 수 있다. A4 : Insecure Direct Object References (안전하지 않은 직접 객체 참조)직접 객체 참조는 개발자가 파일, 디렉토리, 데이터베이스 키와 같은 내부 구현 객체를 참조하는 것을 노출시킬 때 발생한다. 접근 통제를 통한 확인이나 다른 보호수단이 없다면, 공격자는 노출된 참조를 조작하여 허가 받지 않은 데이터에 접근할 수 있다. A5 : Security Misconfiguration (보안 설정 오류)훌륭한 보안은 애플리케이션, 프레임워크, 애플리케이션 서버, 웹 서버, 데이터베이스 서버 및 플랫폼에 대해 보안 설정이 정의되고 적용되어 있다. 기본으로 제공되는 값은 종종 안전하지 않기 때문에 보안 설정은 정의, 구현 및 유지되어야 한다. 또한 소프트웨어는 최신의 상태로 유지해야 한다. A6 : Sensitive Data Exposure (민감 데이터 노출)많은 웹 애플리케이션들이 신용카드, 개인 식별 정보 및 인증 정보와 같은 중요한 데이터를 제대로 보호하지 않는다. 공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하는 등 약하게 보호된 데이터를 훔치거나 변경할 수 있다. 중요 데이터가 저장 또는 전송 중이거나 브라우저와 교환하는 경우 특별히 주의하여야 하며, 암호화와 같은 보호조치를 취해야 한다. A7 : Missing Function Level Access Control (기능 수준의 접근통제 누락)대부분의 웹 애플리케이션은 UI에 해당 기능을 보이게 하기 전에 기능 수준의 접근권한을 확인한다. 그러나, 애플리케이션은 각 기능에 접근하는 서버에 동일한 접근통제 검사를 수행한다. 요청에 대해 적절히 확인하지 않을 경우 공격자는 적절한 권한 없이 기능에 접근하기 위한 요청을 위조할 수 있다. A8 : Cross-Site Request Forgery (CSRF, 크로스 사이트 요청 위조)CSRF 공격은 로그온 된 피해자의 취약한 웹 애플리케이션에 피해자의 세션 쿠키와 기타 다른 인증정보를 자동으로 포함하여 위조된 HTTP 요청을 강제로 보내도록 하는 것이다.이것은 공격자가 취약한 애플리케이션이 피해자로부터의 정당한 요청이라고 오해할 수 있는 요청들을 강제로 만들 수 있다. A9 : Using Components with Known Vulnerabilities (취약점이 있는 컴포넌트 사용)컴포넌트, 라이브러리, 프레임워크 및 다른 소프트웨어 모듈은 대부분 항상 전체 권한으로 실행된다. 이러한 취약한 컴포넌트를 악용하여 공격하는 경우 심각한 데이터 손실이발생하거나 서버가 장악된다. 알려진 취약점이 있는 컴포넌트를 사용하는 애플리케이션은 애플리케이션 방어 체계를 손상하거나, 공격 가능한 범위를 활성화하는 등의 영향을 미친다. A10 : Unvalidated Redirects and Forwards (검증되지 않은 리다이렉트 및 포워드)웹 애플리케이션은 종종 사용자들을 다른 페이지로 리다이렉트 하거나 포워드하고, 대상 페이지를 결정하기 위해 신뢰할 수 없는 데이터를 사용한다. 적절한 검증 절차가 없으면 공격자는 피해자를 피싱 또는 악성코드 사이트로 리다이렉트 하거나 승인되지 않은 페이지에 접근하도록 전달할 수 있다. 참조 OWASP TOP 10https://www.owasp.org/index.php/Top10#OWASP_Top_10_for_2013https://www.owasp.org/images/2/2c/OWASP_Top_10_-_2013_Final_-_Korean.pdf","categories":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"보안","slug":"CSE/보안","permalink":"https://simhyejin.github.io/categories/CSE/보안/"}],"tags":[{"name":"owasp","slug":"owasp","permalink":"https://simhyejin.github.io/tags/owasp/"},{"name":"security","slug":"security","permalink":"https://simhyejin.github.io/tags/security/"}],"keywords":[{"name":"CSE","slug":"CSE","permalink":"https://simhyejin.github.io/categories/CSE/"},{"name":"보안","slug":"CSE/보안","permalink":"https://simhyejin.github.io/categories/CSE/보안/"}]},{"title":"Hexo+GitHub pages","slug":"hexo-github-pages","date":"2016-06-20T07:37:00.000Z","updated":"2019-11-04T08:38:41.490Z","comments":true,"path":"2016/06/20/hexo-github-pages/","link":"","permalink":"https://simhyejin.github.io/2016/06/20/hexo-github-pages/","excerpt":"","text":"이전 포스트 Hexo 정적 블로그 프레임워크에서 Hexo 설치와 설정을 알아봤습니다.제 블로그는 GitHub Pages 와 Hexo 로 운영하고 있습니다.이번 포스트는 GitHub Pages 으로 사이트 만드는 법과 Hexo_와 _GitHub Pages 연동, ERROR Deployer not found: git 오류에 대해 포스트하겠습니다. GitHub PagesGitHub Pages 는 GitHub에서 무료로 호스팅하는 공개 웹페이지입니다.GitHub의 저장소에서 개인이나 조직 또는 프로젝트 페이지를 호스팅하도록 설계되어 있습니다.GitHub에서 제공하는 페이지 제작 도구로 쉽게 페이지를 만들어 공개할 수도 있고, 로컬에서 git을 이용해 수동으로 만들 수도 있습니다. GitHub Pages 의 종류는 크게 두가지로 나뉩니다. 개인 사이트 GitHub Pages 프로젝트 사이트 GitHub Pages 개인 사이트는 &lt;username&gt;.github.io라는 저장소를 만들게되면 자동으로 개인 사이트를 위한 GitHub Pages를 만들 수 있습니다.이 사이트의 저장소 브랜치는 master에서 만들어져야 합니다. 프로젝트 사이트는 GitHub에 등록한 프로젝트별로 사이트를 자동으로 만들 수 있습니다.프로젝트 사이트는 &lt;username&gt;.github.io/[프로젝트 저장소 이름]으로 만들어집니다.사이트의 저장소를 위한 브랜치가 gh-pages라는 브랜치이여야 합니다. 이 블로그는 개인 사이트 Github Pages로 Github 저장소의 이름을 simhyejin.github.io로 설정하여 만들었습니다. GitHub Pages에 대한 자세한 내용은 GitHub help에서 확인할 수 잇습니다. Git pages에 Hexo 적용먼저 hexo-deployer-git을 설치합니다. 1$ npm install hexo-deployer-git --save 주의!ERROR Deployer not found: githexo-deployer-git을 설치 하지 않으면 deploy시 위와 같은 ERROR가 발생합니다. 그 다음 _config.ym 파일을 열어 #deploymeny 부분을 수정합니다. 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Simhyejin/Simhyejin.github.io.git branch: master repo : GitHub repository URLbranch : 브랜치 이름message : 커밋 내용. 커스터마이징 가능합니다. (Site updated:’YYYY-MM-DD HH:mm:ss’ 로 기본 설정되있습니다.) #Blog #Hexo&lt; 이전 포스트 Hexo 정적 블로그 프레임워크다음 포스트 &gt; Hexo 테마 적용하기","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://simhyejin.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://simhyejin.github.io/tags/git/"},{"name":"github-pages","slug":"github-pages","permalink":"https://simhyejin.github.io/tags/github-pages/"},{"name":"deployer","slug":"deployer","permalink":"https://simhyejin.github.io/tags/deployer/"},{"name":"ERROR Deployer not found git","slug":"ERROR-Deployer-not-found-git","permalink":"https://simhyejin.github.io/tags/ERROR-Deployer-not-found-git/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]},{"title":"Hexo 정적 블로그 프레임워크","slug":"blog-start-hexo","date":"2016-06-20T05:16:39.000Z","updated":"2019-11-05T02:40:53.628Z","comments":true,"path":"2016/06/20/blog-start-hexo/","link":"","permalink":"https://simhyejin.github.io/2016/06/20/blog-start-hexo/","excerpt":"","text":"블로그 시작을 위해 사용하였던 Hexo 를 소개합니다. 목차 Hexo Hexo 설치 Hexo 명령어 HexoHexo 는 Node.js 기반 정적 블로그 프레임워크 입니다. 마크다운(Markdown)을 지원하여 손쉬운 포스트 작성 가능 GitHub Pages를 이용한 호스팅을 지원 다양한 테마 제공 등 의 장점으로 이 블로그 또한 Hexo 와 GitHub Pages 로 제작되었습니다.Hexo 설치와 실행법에 대해 소개하겠습니다. Hexo 설치Hexo 를 설치 하기 위해서는 Node.js와 Git이 설치 되어 있어야합니다.아래의 링크를 통해 설치가 가능합니다. Node.js Git Node.js 와 Git_이 설치되어 있다면 이제 **_Hexo** 를 설치할 수 있습니다. 설치터미널을 열어 명령어를 통해 Hexo를 설치합니다. 1$ npm install -g hexo-cli Hexo 가 설치 되었다면 아래의 명령어를 통해 Hexo 폴더를 초기 설정합니다.(디렉토리명은 Github repo 이름과 달라도 무관합니다.) 123$ hexo init &lt;디렉토리명&gt;$ cd &lt;디렉토리명&gt;$ npm install 위 과정이 끝나면 폴더안에 아래의 파일이 생성됩니다. 12345678.├── _config.yml : 사이트 설정 파일. 대부분의 설정 할 수 있습니다. ├── package.json : 응용 프로그램 데이터. ├── scaffolds : 새 게시물을 작성하면 Hexo는 scaffolds 폴더에 새로운 파일을 기반으로 하고 있습니다.├── source : 소스 폴더. 사이트 콘텐츠를 넣어두는 폴더입니다.| ├── _drafts | └── _posts └── themes : 테마 폴더. Hexo는 테마와 콘텐츠를 결합하여 정적 웹 사이트를 생성합니다. 실행모든 설치가 끝났다면 내장 서버를 돌려봅니다. 1$ hexo server localhost:4000을 통해 확인합니다.(기본포트 : 4000) 자주 쓰는 명령어New post새로운 포스트 생성 1$ hexo new \"My New Post\" Generate정적 파일 생성 1$ hexo generate 또는 1$ hexo g Opition으로-d , –deploy : generate가 끝난후 deploy-w , –watch : 파일 변화 확인 deploy원격 사이트에 올리기 1$ hexo deploy 또는 1$ hexo d Opition으로-g , –generate : deploy 전에 generate 그 외에는 Hexo Commands에서 확인 할 수 있습니다. #Blog #Hexo다음 포스트 &gt; Hexo+GitHub pages","categories":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://simhyejin.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://simhyejin.github.io/tags/hexo/"},{"name":"정적 블로그 프레임워크","slug":"정적-블로그-프레임워크","permalink":"https://simhyejin.github.io/tags/정적-블로그-프레임워크/"},{"name":"git","slug":"git","permalink":"https://simhyejin.github.io/tags/git/"},{"name":"Node.js","slug":"Node-js","permalink":"https://simhyejin.github.io/tags/Node-js/"},{"name":"헥소","slug":"헥소","permalink":"https://simhyejin.github.io/tags/헥소/"},{"name":"Static Site Generator","slug":"Static-Site-Generator","permalink":"https://simhyejin.github.io/tags/Static-Site-Generator/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"https://simhyejin.github.io/categories/Blog/"}]}]}